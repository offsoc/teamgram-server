package hsm

import (
	"fmt"
	"testing"
	"time"
)

// TestHSMInitialization tests HSM initialization
func TestHSMInitialization(t *testing.T) {
	t.Logf("=== HSM INITIALIZATION TEST ===")
	
	config := &HSMConfig{
		Vendor:           VendorSimulator,
		ConnectTimeout:   5 * time.Second,
		OperationTimeout: 1 * time.Second,
		MaxRetries:       3,
		SessionPoolSize:  5,
	}
	
	hsm, err := NewHSM(config)
	if err != nil {
		t.Fatalf("Failed to create HSM: %v", err)
	}
	defer hsm.Disconnect()
	
	if !hsm.IsConnected() {
		t.Errorf("HSM should be connected after initialization")
	}
	
	status, err := hsm.GetStatus()
	if err != nil {
		t.Fatalf("Failed to get HSM status: %v", err)
	}
	
	if !status.IsOnline {
		t.Errorf("HSM should be online")
	}
	
	if status.FIPS140Level != 4 {
		t.Errorf("Expected FIPS 140-3 Level 4, got %d", status.FIPS140Level)
	}
	
	t.Logf("✓ HSM initialized successfully")
	t.Logf("  Vendor: %s", status.Vendor)
	t.Logf("  Model: %s", status.Model)
	t.Logf("  Serial: %s", status.SerialNumber)
	t.Logf("  FIPS Level: %d", status.FIPS140Level)
}

// TestHSMRandomGeneration tests random number generation
func TestHSMRandomGeneration(t *testing.T) {
	t.Logf("=== HSM RANDOM GENERATION TEST ===")
	
	config := &HSMConfig{
		Vendor:           VendorSimulator,
		ConnectTimeout:   5 * time.Second,
		OperationTimeout: 1 * time.Second,
	}
	
	hsm, err := NewHSM(config)
	if err != nil {
		t.Fatalf("Failed to create HSM: %v", err)
	}
	defer hsm.Disconnect()
	
	// Test various sizes
	sizes := []int{16, 32, 64, 128, 256, 1024}
	
	for _, size := range sizes {
		t.Run(fmt.Sprintf("Size%d", size), func(t *testing.T) {
			start := time.Now()
			
			randomBytes, err := hsm.GenerateRandom(size)
			if err != nil {
				t.Fatalf("Failed to generate %d random bytes: %v", size, err)
			}
			
			duration := time.Since(start)
			
			if len(randomBytes) != size {
				t.Errorf("Expected %d bytes, got %d", size, len(randomBytes))
			}
			
			// Check for non-zero bytes (basic entropy check)
			hasNonZero := false
			for _, b := range randomBytes {
				if b != 0 {
					hasNonZero = true
					break
				}
			}
			
			if !hasNonZero {
				t.Errorf("Generated bytes appear to be all zeros")
			}
			
			t.Logf("✓ Generated %d bytes in %v", size, duration)
			
			// Performance requirement: < 1ms for reasonable sizes
			if size <= 1024 && duration > time.Millisecond {
				t.Errorf("Random generation too slow: %v > 1ms for %d bytes", duration, size)
			}
		})
	}
}

// TestHSMPerformanceRequirements tests performance requirements
func TestHSMPerformanceRequirements(t *testing.T) {
	t.Logf("=== HSM PERFORMANCE REQUIREMENTS TEST ===")
	
	config := &HSMConfig{
		Vendor:           VendorSimulator,
		ConnectTimeout:   5 * time.Second,
		OperationTimeout: 1 * time.Second,
	}
	
	hsm, err := NewHSM(config)
	if err != nil {
		t.Fatalf("Failed to create HSM: %v", err)
	}
	defer hsm.Disconnect()
	
	// Test random generation performance
	t.Run("RandomGenerationLatency", func(t *testing.T) {
		iterations := 100
		totalDuration := time.Duration(0)
		
		for i := 0; i < iterations; i++ {
			start := time.Now()
			_, err := hsm.GenerateRandom(32)
			duration := time.Since(start)
			
			if err != nil {
				t.Fatalf("Random generation failed: %v", err)
			}
			
			totalDuration += duration
		}
		
		avgDuration := totalDuration / time.Duration(iterations)
		t.Logf("Average random generation latency: %v", avgDuration)
		
		// Requirement: < 1ms
		if avgDuration > time.Millisecond {
			t.Errorf("Average latency too high: %v > 1ms", avgDuration)
		} else {
			t.Logf("✓ Latency requirement met: %v < 1ms", avgDuration)
		}
	})
	
	// Test availability
	t.Run("Availability", func(t *testing.T) {
		iterations := 1000
		successCount := 0
		
		for i := 0; i < iterations; i++ {
			_, err := hsm.GenerateRandom(16)
			if err == nil {
				successCount++
			}
		}
		
		availability := float64(successCount) / float64(iterations) * 100
		t.Logf("Availability: %.4f%%", availability)
		
		// Requirement: > 99.99%
		if availability < 99.99 {
			t.Errorf("Availability too low: %.4f%% < 99.99%%", availability)
		} else {
			t.Logf("✓ Availability requirement met: %.4f%% > 99.99%%", availability)
		}
	})
	
	// Test metrics
	metrics, err := hsm.GetMetrics()
	if err != nil {
		t.Fatalf("Failed to get metrics: %v", err)
	}
	
	t.Logf("Performance Metrics:")
	t.Logf("  Total Operations: %d", metrics.TotalOperations)
	t.Logf("  Successful Operations: %d", metrics.SuccessfulOperations)
	t.Logf("  Failed Operations: %d", metrics.FailedOperations)
	t.Logf("  Error Rate: %.4f%%", metrics.ErrorRate*100)
	t.Logf("  Availability: %.4f%%", metrics.Availability*100)
	t.Logf("  Average Latency: %v", metrics.AverageLatency)
	t.Logf("  Max Latency: %v", metrics.MaxLatency)
	t.Logf("  Min Latency: %v", metrics.MinLatency)
}

// TestHSMKeyGeneration tests key generation
func TestHSMKeyGeneration(t *testing.T) {
	t.Logf("=== HSM KEY GENERATION TEST ===")
	
	config := &HSMConfig{
		Vendor:           VendorSimulator,
		ConnectTimeout:   5 * time.Second,
		OperationTimeout: 1 * time.Second,
	}
	
	hsm, err := NewHSM(config)
	if err != nil {
		t.Fatalf("Failed to create HSM: %v", err)
	}
	defer hsm.Disconnect()
	
	keyTypes := []struct {
		keyType KeyType
		keySize int
	}{
		{KeyTypeAES, 256},
		{KeyTypeRSA, 2048},
		{KeyTypeECC, 256},
	}
	
	for _, kt := range keyTypes {
		t.Run(fmt.Sprintf("%v-%d", kt.keyType, kt.keySize), func(t *testing.T) {
			start := time.Now()

			key, err := hsm.GenerateKey(kt.keyType, kt.keySize)
			if err != nil {
				t.Fatalf("Failed to generate %v-%d key: %v", kt.keyType, kt.keySize, err)
			}

			duration := time.Since(start)

			if key == nil {
				t.Errorf("Generated key is nil")
			}

			if key.Type != kt.keyType {
				t.Errorf("Expected key type %v, got %v", kt.keyType, key.Type)
			}

			if key.Size != kt.keySize {
				t.Errorf("Expected key size %d, got %d", kt.keySize, key.Size)
			}

			t.Logf("✓ Generated %v-%d key in %v", kt.keyType, kt.keySize, duration)
		})
	}
}

// TestHSMSelfTest tests HSM self-test functionality
func TestHSMSelfTest(t *testing.T) {
	t.Logf("=== HSM SELF-TEST ===")
	
	config := &HSMConfig{
		Vendor:           VendorSimulator,
		ConnectTimeout:   5 * time.Second,
		OperationTimeout: 1 * time.Second,
	}
	
	hsm, err := NewHSM(config)
	if err != nil {
		t.Fatalf("Failed to create HSM: %v", err)
	}
	defer hsm.Disconnect()
	
	start := time.Now()
	err = hsm.SelfTest()
	duration := time.Since(start)
	
	if err != nil {
		t.Fatalf("HSM self-test failed: %v", err)
	}
	
	t.Logf("✓ HSM self-test passed in %v", duration)
	
	// Self-test should be fast
	if duration > 5*time.Second {
		t.Errorf("Self-test too slow: %v > 5s", duration)
	}
}

// TestHSMErrorHandling tests error handling
func TestHSMErrorHandling(t *testing.T) {
	t.Logf("=== HSM ERROR HANDLING TEST ===")
	
	// Test with invalid configuration
	t.Run("InvalidConfig", func(t *testing.T) {
		_, err := NewHSM(nil)
		if err == nil {
			t.Errorf("Expected error for nil config")
		}
	})
	
	// Test operations on disconnected HSM
	t.Run("DisconnectedOperations", func(t *testing.T) {
		config := &HSMConfig{
			Vendor:           VendorSimulator,
			ConnectTimeout:   5 * time.Second,
			OperationTimeout: 1 * time.Second,
		}
		
		hsm, err := NewHSM(config)
		if err != nil {
			t.Fatalf("Failed to create HSM: %v", err)
		}
		
		// Disconnect HSM
		hsm.Disconnect()
		
		// Try operations on disconnected HSM
		_, err = hsm.GenerateRandom(32)
		if err == nil {
			t.Errorf("Expected error for operation on disconnected HSM")
		}
		
		_, err = hsm.GenerateKey(KeyTypeAES, 256)
		if err == nil {
			t.Errorf("Expected error for key generation on disconnected HSM")
		}
	})
	
	// Test invalid parameters
	t.Run("InvalidParameters", func(t *testing.T) {
		config := &HSMConfig{
			Vendor:           VendorSimulator,
			ConnectTimeout:   5 * time.Second,
			OperationTimeout: 1 * time.Second,
		}
		
		hsm, err := NewHSM(config)
		if err != nil {
			t.Fatalf("Failed to create HSM: %v", err)
		}
		defer hsm.Disconnect()
		
		// Test invalid random size
		_, err = hsm.GenerateRandom(0)
		if err == nil {
			t.Errorf("Expected error for zero random size")
		}
		
		_, err = hsm.GenerateRandom(-1)
		if err == nil {
			t.Errorf("Expected error for negative random size")
		}
		
		_, err = hsm.GenerateRandom(2 * 1024 * 1024) // 2MB
		if err == nil {
			t.Errorf("Expected error for too large random size")
		}
	})
	
	t.Logf("✓ Error handling tests completed")
}
